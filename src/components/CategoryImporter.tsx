/**
 * CategoryImporter Component
 *
 * Allows users to import category data from JSON files (generated by scripts/parse_pptx.py)
 * and review/edit the data before adding it to the application.
 * Supports importing multiple contestants - shows one at a time with Next button.
 */

import { useState, useEffect } from 'react';
import type { Category } from '@types';
import { loadCategoryJSON, JSONImportError } from '@utils/jsonImport';
import { SlidePreview } from '@components/slide/SlidePreview';
import {
  getSampleCategories,
  fetchSampleCategory,
  type SampleCategoryMeta,
} from '@utils/sampleCategories';
import styles from './CategoryImporter.module.css';

interface ContestantData {
  file: File | null; // null for sample categories
  category: Category;
  contestantName: string;
  categoryName: string;
  error: string | null;
  isSample?: boolean; // Track if this is from sample categories
}

interface CategoryImporterProps {
  onImport: (contestants: { name: string; category: Category }[]) => void | Promise<void>;
  onCancel: () => void;
  initialContestantName?: string;
  fileSizeWarningThresholdMB?: number;
}

export function CategoryImporter({
  onImport,
  onCancel: _onCancel,
  initialContestantName,
  fileSizeWarningThresholdMB = 30,
}: CategoryImporterProps) {
  const [allContestants, setAllContestants] = useState<ContestantData[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  const [expandedSlideIndex, setExpandedSlideIndex] = useState<number | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [sampleCategories, setSampleCategories] = useState<SampleCategoryMeta[]>([]);
  const [showSampleCategories, setShowSampleCategories] = useState(false);
  const [selectedSamples, setSelectedSamples] = useState<Set<string>>(new Set());

  // Load sample categories on mount
  useEffect(() => {
    try {
      const samples = getSampleCategories();
      setSampleCategories(samples);
    } catch (error) {
      console.error('Failed to load sample categories:', error);
    }
  }, []);

  const currentContestant = allContestants[currentIndex];
  const isLastContestant = currentIndex === allContestants.length - 1;

  const processFiles = async (files: FileList) => {
    if (files.length === 0) {
      return;
    }

    setIsLoading(true);
    setCurrentIndex(0);
    setExpandedSlideIndex(null);

    const contestants: ContestantData[] = [];

    // Process all selected files
    for (const file of files) {
      try {
        const loadedCategory = await loadCategoryJSON(file);

        // Use initialContestantName if provided, otherwise extract from filename
        let name = initialContestantName ?? '';

        if (!name) {
          // Try to extract contestant name from filename (e.g., "john-movies.json" -> "John")
          const fileNameWithoutExt = file.name.replace(/\.json$/i, '');
          const parts = fileNameWithoutExt.split('-');
          if (parts.length > 0 && parts[0]) {
            name = parts[0].charAt(0).toUpperCase() + parts[0].slice(1);
          }
        }

        contestants.push({
          file,
          category: loadedCategory,
          contestantName: name,
          categoryName: loadedCategory.name,
          error: null,
        });
      } catch (err) {
        contestants.push({
          file,
          category: { name: '', slides: [] },
          contestantName: '',
          categoryName: '',
          error: err instanceof JSONImportError ? err.message : 'Failed to load file',
        });
      }
    }

    setAllContestants(contestants);
    setIsLoading(false);
  };

  const handleFileChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files !== null) {
      await processFiles(files);
    }
  };

  const handleDrop = async (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(false);
    const files = event.dataTransfer.files;
    await processFiles(files);
  };

  const handleDragOver = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const toggleSampleSelection = (filename: string) => {
    setSelectedSamples((prev) => {
      const next = new Set(prev);
      if (next.has(filename)) {
        next.delete(filename);
      } else {
        next.add(filename);
      }
      return next;
    });
  };

  const handleLoadSelectedSamples = async () => {
    if (selectedSamples.size === 0) {
      return;
    }

    setIsLoading(true);
    setShowSampleCategories(false);
    setCurrentIndex(0);
    setExpandedSlideIndex(null);

    const filenames = Array.from(selectedSamples);

    // Load only the first category immediately for fast UI
    const firstFilename = filenames[0];
    if (!firstFilename) {
      setIsLoading(false);
      return;
    }

    try {
      const firstCategory = await fetchSampleCategory(firstFilename);

      // Show first category immediately
      setAllContestants([
        {
          file: null,
          category: firstCategory,
          contestantName: initialContestantName ?? '',
          categoryName: firstCategory.name,
          error: null,
          isSample: true,
        },
      ]);
      setIsLoading(false);

      // Prefetch remaining categories in background
      if (filenames.length > 1) {
        // Load the rest in parallel
        const remainingPromises = filenames.slice(1).map(async (filename) => {
          try {
            const category = await fetchSampleCategory(filename);
            return {
              file: null,
              category,
              contestantName: initialContestantName ?? '',
              categoryName: category.name,
              error: null,
              isSample: true,
            } as ContestantData;
          } catch (error) {
            return {
              file: null,
              category: { name: '', slides: [] },
              contestantName: '',
              categoryName: '',
              error: error instanceof Error ? error.message : 'Failed to load sample category',
              isSample: true,
            } as ContestantData;
          }
        });

        const remainingContestants = await Promise.all(remainingPromises);

        // Append the rest to the list
        setAllContestants((prev) => [...prev, ...remainingContestants]);
      }
    } catch (error) {
      // First category failed to load
      setAllContestants([
        {
          file: null,
          category: { name: '', slides: [] },
          contestantName: '',
          categoryName: '',
          error: error instanceof Error ? error.message : 'Failed to load sample category',
          isSample: true,
        },
      ]);
      setIsLoading(false);
    }

    setSelectedSamples(new Set()); // Clear selection
  };

  const updateCurrentContestantName = (name: string) => {
    setAllContestants((prev) =>
      prev.map((c, i) => (i === currentIndex ? { ...c, contestantName: name } : c))
    );
  };

  const updateCurrentCategoryName = (name: string) => {
    setAllContestants((prev) =>
      prev.map((c, i) => (i === currentIndex ? { ...c, categoryName: name } : c))
    );
  };

  const handleSlideAnswerChange = (slideIndex: number, newAnswer: string) => {
    setAllContestants((prev) =>
      prev.map((contestant, i) => {
        if (i !== currentIndex) {
          return contestant;
        }

        const updatedSlides = contestant.category.slides.map((slide, sIndex) =>
          sIndex === slideIndex ? { ...slide, answer: newAnswer } : slide
        );

        return {
          ...contestant,
          category: {
            ...contestant.category,
            slides: updatedSlides,
          },
        };
      })
    );
  };

  const toggleSlideExpanded = (slideIndex: number) => {
    setExpandedSlideIndex((prev) => (prev === slideIndex ? null : slideIndex));
  };

  const handleNext = () => {
    if (!currentContestant || currentContestant.error) {
      return;
    }

    // Move to next contestant
    if (!isLastContestant) {
      setCurrentIndex((prev) => prev + 1);
      setExpandedSlideIndex(null);
    }
  };

  const handleImportAll = () => {
    // Validate current contestant
    if (currentContestant?.error) {
      return;
    }

    // Prepare all valid imports (contestants and/or categories)
    const contestantsToImport = allContestants
      .filter((c) => !c.error)
      .map((c) => ({
        name: c.contestantName.trim() || '', // Empty string if no contestant name
        category: {
          ...c.category,
          name: c.categoryName.trim() || c.category.name,
        },
      }));

    if (contestantsToImport.length === 0) {
      return;
    }

    void onImport(contestantsToImport);
  };

  const categoryImporterClass = styles['category-importer'] ?? '';
  const dropZoneClass = styles['drop-zone'] ?? '';
  const draggingClass = isDragging ? (styles['dragging'] ?? '') : '';
  const dropZoneContentClass = styles['drop-zone-content'] ?? '';
  const dropIconClass = styles['drop-icon'] ?? '';
  const dropTextPrimaryClass = styles['drop-text-primary'] ?? '';
  const dropTextSecondaryClass = styles['drop-text-secondary'] ?? '';
  const dropSupportedTypesClass = styles['drop-supported-types'] ?? '';
  const loadingClass = styles['loading'] ?? '';
  const fileInfoClass = styles['file-info'] ?? '';
  const fileNameClass = styles['file-name'] ?? '';

  return (
    <div className={categoryImporterClass}>
      {allContestants.length === 0 ? (
        <>
          {/* File upload drop zone */}
          <div
            className={`${dropZoneClass} ${draggingClass}`.trim()}
            onDrop={(e) => {
              void handleDrop(e);
            }}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
          >
            <input
              id="json-file-input"
              type="file"
              accept=".json,application/json"
              onChange={(e) => {
                void handleFileChange(e);
              }}
              disabled={isLoading}
              multiple
              style={{ display: 'none' }}
            />
            <label htmlFor="json-file-input" className={dropZoneContentClass}>
              {isLoading ? (
                <p className={loadingClass}>Loading and validating...</p>
              ) : (
                <>
                  <div className={dropIconClass}>üìÅ</div>
                  <div className={dropTextPrimaryClass}>Drag & drop category files here</div>
                  <div className={dropTextSecondaryClass}>or click to browse</div>
                  <div className={dropSupportedTypesClass}>Supported: .json</div>
                </>
              )}
            </label>
          </div>

          {/* Sample categories section - outside drop zone */}
          {!isLoading && sampleCategories.length > 0 && (
            <div className={styles['sample-categories-section'] ?? ''}>
              <div className={styles['section-divider'] ?? ''}>
                <span>OR</span>
              </div>
              <button
                type="button"
                onClick={() => {
                  if (showSampleCategories && selectedSamples.size > 0) {
                    void handleLoadSelectedSamples();
                  } else {
                    setShowSampleCategories(!showSampleCategories);
                  }
                }}
                className={`${styles['browse-samples-button'] ?? ''} ${
                  selectedSamples.size > 0 ? (styles['load-active'] ?? '') : ''
                }`.trim()}
              >
                {showSampleCategories && selectedSamples.size > 0
                  ? `Load ${String(selectedSamples.size)} Sample ${selectedSamples.size === 1 ? 'Category' : 'Categories'}`
                  : showSampleCategories
                    ? '‚Üê Back'
                    : 'üì¶ Browse Sample Categories'}
              </button>

              {showSampleCategories && (
                <div className={styles['sample-categories-list'] ?? ''}>
                  <h4>Available Sample Categories ({sampleCategories.length})</h4>
                  <div className={styles['sample-grid'] ?? ''}>
                    {sampleCategories.map((sample) => {
                      const isSelected = selectedSamples.has(sample.filename);
                      return (
                        <button
                          key={sample.filename}
                          type="button"
                          onClick={() => {
                            toggleSampleSelection(sample.filename);
                          }}
                          className={`${styles['sample-category-button'] ?? ''} ${
                            isSelected ? (styles['selected'] ?? '') : ''
                          }`.trim()}
                          aria-pressed={isSelected}
                        >
                          {isSelected && <span className={styles['checkmark'] ?? ''}>‚úì</span>}
                          {sample.name}
                        </button>
                      );
                    })}
                  </div>
                </div>
              )}
            </div>
          )}
        </>
      ) : (
        <div className={fileInfoClass}>
          <div>
            {currentContestant ? (
              <div className={fileNameClass}>
                {currentContestant.isSample ? (
                  <>
                    üì¶ Sample: {currentContestant.categoryName}
                    <span className={styles['sample-badge'] ?? ''}>Demo Category</span>
                  </>
                ) : currentContestant.file ? (
                  <>
                    üìÑ {currentContestant.file.name}
                    <span className={styles['file-size'] ?? ''}>
                      {(() => {
                        const sizeInMB = currentContestant.file.size / (1024 * 1024);
                        const isLarge = sizeInMB > fileSizeWarningThresholdMB;
                        const sizeText =
                          sizeInMB < 1
                            ? `${(currentContestant.file.size / 1024).toFixed(1)} KB`
                            : `${sizeInMB.toFixed(1)} MB`;
                        return (
                          <span className={isLarge ? (styles['file-size-warning'] ?? '') : ''}>
                            {sizeText}
                            {isLarge && ' ‚ö†Ô∏è Large file - may be slow'}
                          </span>
                        );
                      })()}
                    </span>
                    {allContestants.length > 1 && (
                      <span className={styles['file-counter'] ?? ''}>
                        {' '}
                        (File {currentIndex + 1} of {allContestants.length})
                      </span>
                    )}
                  </>
                ) : null}
              </div>
            ) : null}
          </div>
          {currentContestant &&
            (!isLastContestant ? (
              <button
                type="button"
                onClick={handleNext}
                disabled={!currentContestant.categoryName.trim()}
                className={styles['next-button'] ?? ''}
              >
                Next ‚Üí
              </button>
            ) : (
              <button
                type="button"
                onClick={handleImportAll}
                disabled={!currentContestant.categoryName.trim()}
                className={styles['import-button-inline'] ?? ''}
              >
                {(() => {
                  const contestantCount = allContestants.filter(
                    (c) => !c.error && c.contestantName.trim()
                  ).length;
                  const categoryCount = allContestants.filter((c) => !c.error).length;

                  if (contestantCount > 0) {
                    if (contestantCount === 1) {
                      return 'Import Contestant';
                    }
                    return `Import ${String(contestantCount)} Contestants`;
                  } else {
                    if (categoryCount === 1) {
                      return 'Import Category';
                    }
                    return `Import ${String(categoryCount)} Categories`;
                  }
                })()}
              </button>
            ))}
        </div>
      )}

      {currentContestant?.error && (
        <div className={styles['error-message'] ?? ''} role="alert">
          <strong>Error:</strong> {currentContestant.error}
        </div>
      )}

      {currentContestant && !currentContestant.error && !isLoading && (
        <div className={styles['preview-section'] ?? ''}>
          <h3>Preview</h3>

          <div className={styles['form-group'] ?? ''}>
            <label htmlFor="contestant-name-input">
              Contestant Name{' '}
              <span style={{ color: 'var(--text-secondary)', fontWeight: 'normal' }}>
                (optional)
              </span>
              :
            </label>
            <input
              id="contestant-name-input"
              type="text"
              value={currentContestant.contestantName}
              onChange={(e) => {
                updateCurrentContestantName(e.target.value);
              }}
              placeholder="Leave empty to import category only"
            />
            <p
              style={{
                fontSize: '0.85rem',
                color: 'var(--text-secondary)',
                margin: '0.25rem 0 0 0',
              }}
            >
              If provided, a contestant will be created with this category. Otherwise, only the
              category will be imported.
            </p>
          </div>

          <div className={styles['form-group'] ?? ''}>
            <label htmlFor="category-name-input">Category Name:</label>
            <input
              id="category-name-input"
              type="text"
              value={currentContestant.categoryName}
              onChange={(e) => {
                updateCurrentCategoryName(e.target.value);
              }}
              placeholder="Enter category name"
              required
            />
          </div>

          <div className={styles['slides-summary'] ?? ''}>
            <h4>Slides: {currentContestant.category.slides.length}</h4>
            <p style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginBottom: '1rem' }}>
              Click on any slide to expand and edit its answer. Answers are censored by default to
              prevent spoilers.
            </p>
            <div className={styles['slides-list'] ?? ''}>
              {currentContestant.category.slides.map((slide, index) => (
                <SlidePreview
                  key={index}
                  slide={slide}
                  slideNumber={index + 1}
                  mode="edit"
                  isExpanded={expandedSlideIndex === index}
                  onToggleExpand={() => {
                    toggleSlideExpanded(index);
                  }}
                  onAnswerChange={(newAnswer) => {
                    handleSlideAnswerChange(index, newAnswer);
                  }}
                />
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
