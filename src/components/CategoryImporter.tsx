/**
 * CategoryImporter Component
 *
 * Allows users to import category data from JSON files (generated by scripts/parse_pptx.py)
 * and review/edit the data before adding it to the application.
 * Supports importing multiple contestants - shows one at a time with Next button.
 */

import { useState, useEffect } from 'react';
import type { Category } from '@types';
import { loadCategoryJSON, JSONImportError } from '@utils/jsonImport';
import { SlidePreview } from '@components/slide/SlidePreview';
import { createLogger } from '@/utils/logger';
import styles from './CategoryImporter.module.css';

const log = createLogger('CategoryImporter');

interface ContestantData {
  file: File | null; // null for sample categories
  category: Category;
  contestantName: string;
  categoryName: string;
  error: string | null;
  isSample?: boolean; // Track if this is from sample categories
  sizeBytes?: number; // File size in bytes (only for file uploads, not needed for in-memory calculation)
}

interface CategoryImporterProps {
  onImport: (
    contestants: { name: string; category: Category }[]
  ) => // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  | void
    | Promise<void>
    | Promise<string[]>
    | Promise<{ categoryId: string; contestantId?: string }[]>;
  onCancel: () => void;
  initialContestantName?: string;
  fileSizeWarningThresholdMB?: number;
  onBrowseSamples?: () => void;
  onFilesLoaded?: (categories: { name: string; category: Category }[]) => void; // NEW: Called when files are dropped and parsed
  preloadedCategories?: { name: string; category: Category }[] | null; // For preview mode
}

export function CategoryImporter({
  onImport,
  onCancel: _onCancel,
  initialContestantName,
  fileSizeWarningThresholdMB = 30,
  onBrowseSamples,
  onFilesLoaded,
  preloadedCategories,
}: CategoryImporterProps) {
  const [allContestants, setAllContestants] = useState<ContestantData[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  const [expandedSlideIndex, setExpandedSlideIndex] = useState<number | null>(null);
  const [isDragging, setIsDragging] = useState(false);

  // Load preloaded categories when provided
  useEffect(() => {
    if (preloadedCategories && preloadedCategories.length > 0) {
      const contestants: ContestantData[] = preloadedCategories.map((item) => ({
        file: null,
        category: item.category,
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        contestantName: item.name || initialContestantName || '',
        categoryName: item.category.name,
        error: null,
        isSample: true,
      }));
      setAllContestants(contestants);
      setCurrentIndex(0);
      setExpandedSlideIndex(null);
    }
  }, [preloadedCategories, initialContestantName]);

  const currentContestant = allContestants[currentIndex];
  const isLastContestant = currentIndex === allContestants.length - 1;

  const processFiles = async (files: FileList) => {
    if (files.length === 0) {
      return;
    }

    setIsLoading(true);
    setCurrentIndex(0);
    setExpandedSlideIndex(null);

    const contestants: ContestantData[] = [];

    // Process all selected files
    for (const file of files) {
      try {
        const loadedCategory = await loadCategoryJSON(file);

        // Use initialContestantName if provided, otherwise leave blank
        const name = initialContestantName ?? '';

        contestants.push({
          file,
          category: loadedCategory,
          contestantName: name,
          categoryName: loadedCategory.name, // Always use category.name from JSON
          error: null,
          sizeBytes: file.size,
        });
      } catch (err) {
        contestants.push({
          file,
          category: { name: '', slides: [] },
          contestantName: '',
          categoryName: '',
          error: err instanceof JSONImportError ? err.message : 'Failed to load file',
          sizeBytes: file.size,
        });
      }
    }

    setIsLoading(false);

    // If onFilesLoaded callback provided, call it instead of showing preview internally
    if (onFilesLoaded) {
      log.debug('Calling onFilesLoaded with parsed files');
      const loadedCategories = contestants
        .filter((c) => c.error === null)
        .map((c) => ({
          name: c.contestantName,
          category: c.category,
        }));
      onFilesLoaded(loadedCategories);
    } else {
      // Fallback: show preview internally (backward compatibility)
      setAllContestants(contestants);
    }
  };

  const handleFileChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files !== null) {
      await processFiles(files);
    }
  };

  const handleDrop = async (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(false);
    const files = event.dataTransfer.files;
    await processFiles(files);
  };

  const handleDragOver = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const updateCurrentContestantName = (name: string) => {
    setAllContestants((prev) =>
      prev.map((c, i) => (i === currentIndex ? { ...c, contestantName: name } : c))
    );
  };

  const updateCurrentCategoryName = (name: string) => {
    setAllContestants((prev) =>
      prev.map((c, i) => (i === currentIndex ? { ...c, categoryName: name } : c))
    );
  };

  const handleSlideAnswerChange = (slideIndex: number, newAnswer: string) => {
    setAllContestants((prev) =>
      prev.map((contestant, i) => {
        if (i !== currentIndex) {
          return contestant;
        }

        const updatedSlides = contestant.category.slides.map((slide, sIndex) =>
          sIndex === slideIndex ? { ...slide, answer: newAnswer } : slide
        );

        return {
          ...contestant,
          category: {
            ...contestant.category,
            slides: updatedSlides,
          },
        };
      })
    );
  };

  const toggleSlideExpanded = (slideIndex: number) => {
    setExpandedSlideIndex((prev) => (prev === slideIndex ? null : slideIndex));
  };

  const handleNext = () => {
    if (!currentContestant || currentContestant.error) {
      return;
    }

    // Move to next contestant
    if (!isLastContestant) {
      setCurrentIndex((prev) => prev + 1);
      setExpandedSlideIndex(null);
    }
  };

  const handleImportAll = () => {
    // Validate current contestant
    if (currentContestant?.error) {
      return;
    }

    // Prepare all valid imports (contestants and/or categories)
    const contestantsToImport = allContestants
      .filter((c) => !c.error)
      .map((c) => ({
        name: c.contestantName.trim() || '', // Empty string if no contestant name
        category: {
          ...c.category,
          name: c.categoryName.trim() || c.category.name,
        },
      }));

    if (contestantsToImport.length === 0) {
      return;
    }

    void onImport(contestantsToImport);
  };

  const categoryImporterClass = styles['category-importer'] ?? '';
  const dropZoneClass = styles['drop-zone'] ?? '';
  const draggingClass = isDragging ? (styles['dragging'] ?? '') : '';
  const dropZoneContentClass = styles['drop-zone-content'] ?? '';
  const dropIconClass = styles['drop-icon'] ?? '';
  const dropTextPrimaryClass = styles['drop-text-primary'] ?? '';
  const dropTextSecondaryClass = styles['drop-text-secondary'] ?? '';
  const dropSupportedTypesClass = styles['drop-supported-types'] ?? '';
  const loadingClass = styles['loading'] ?? '';
  const fileInfoClass = styles['file-info'] ?? '';
  const fileNameClass = styles['file-name'] ?? '';

  return (
    <div className={categoryImporterClass}>
      {allContestants.length === 0 ? (
        <>
          {/* File upload drop zone */}
          <div
            className={`${dropZoneClass} ${draggingClass}`.trim()}
            onDrop={(e) => {
              void handleDrop(e);
            }}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
          >
            <input
              id="json-file-input"
              type="file"
              accept=".json,application/json"
              onChange={(e) => {
                void handleFileChange(e);
              }}
              disabled={isLoading}
              multiple
              style={{ display: 'none' }}
            />
            <label htmlFor="json-file-input" className={dropZoneContentClass}>
              {isLoading ? (
                <p className={loadingClass}>Loading and validating...</p>
              ) : (
                <>
                  <div className={dropIconClass}>üìÅ</div>
                  <div className={dropTextPrimaryClass}>Drag & drop category files here</div>
                  <div className={dropTextSecondaryClass}>or click to browse</div>
                  <div className={dropSupportedTypesClass}>Supported: .json</div>
                </>
              )}
            </label>
          </div>

          {/* Sample categories section - outside drop zone */}
          {!isLoading && onBrowseSamples && (
            <div className={styles['sample-categories-section'] ?? ''}>
              <div className={styles['section-divider'] ?? ''}>
                <span>OR</span>
              </div>
              <button
                type="button"
                onClick={onBrowseSamples}
                className={styles['browse-samples-button'] ?? ''}
              >
                üì¶ Browse Sample Categories
              </button>
            </div>
          )}
        </>
      ) : (
        <div className={fileInfoClass}>
          <div>
            {currentContestant ? (
              <div className={fileNameClass}>
                {currentContestant.isSample ? (
                  <>
                    üì¶ {currentContestant.categoryName}
                    {currentContestant.sizeBytes !== undefined && (
                      <span className={styles['file-size'] ?? ''}>
                        {(() => {
                          const sizeInMB = currentContestant.sizeBytes / (1024 * 1024);
                          const sizeText =
                            sizeInMB < 1
                              ? `${(currentContestant.sizeBytes / 1024).toFixed(1)} KB`
                              : `${sizeInMB.toFixed(1)} MB`;
                          return sizeText;
                        })()}
                      </span>
                    )}
                    <span className={styles['sample-badge'] ?? ''}>Sample</span>
                  </>
                ) : currentContestant.file ? (
                  <>
                    üìÑ {currentContestant.file.name}
                    <span className={styles['file-size'] ?? ''}>
                      {(() => {
                        const sizeInMB = currentContestant.file.size / (1024 * 1024);
                        const isLarge = sizeInMB > fileSizeWarningThresholdMB;
                        const sizeText =
                          sizeInMB < 1
                            ? `${(currentContestant.file.size / 1024).toFixed(1)} KB`
                            : `${sizeInMB.toFixed(1)} MB`;
                        return (
                          <span className={isLarge ? (styles['file-size-warning'] ?? '') : ''}>
                            {sizeText}
                            {isLarge && ' ‚ö†Ô∏è Large file - may be slow'}
                          </span>
                        );
                      })()}
                    </span>
                    {allContestants.length > 1 && (
                      <span className={styles['file-counter'] ?? ''}>
                        {' '}
                        (File {currentIndex + 1} of {allContestants.length})
                      </span>
                    )}
                  </>
                ) : null}
              </div>
            ) : null}
          </div>
          {currentContestant &&
            (!isLastContestant ? (
              <button
                type="button"
                onClick={handleNext}
                disabled={!currentContestant.categoryName.trim()}
                className={styles['next-button'] ?? ''}
              >
                Next ‚Üí
              </button>
            ) : (
              <button
                type="button"
                onClick={handleImportAll}
                disabled={!currentContestant.categoryName.trim()}
                className={styles['import-button-inline'] ?? ''}
              >
                {(() => {
                  const contestantCount = allContestants.filter(
                    (c) => !c.error && c.contestantName.trim()
                  ).length;
                  const categoryCount = allContestants.filter((c) => !c.error).length;

                  if (contestantCount > 0) {
                    if (contestantCount === 1) {
                      return 'Import Contestant';
                    }
                    return `Import ${String(contestantCount)} Contestants`;
                  } else {
                    if (categoryCount === 1) {
                      return 'Import Category';
                    }
                    return `Import ${String(categoryCount)} Categories`;
                  }
                })()}
              </button>
            ))}
        </div>
      )}

      {currentContestant?.error && (
        <div className={styles['error-message'] ?? ''} role="alert">
          <strong>Error:</strong> {currentContestant.error}
        </div>
      )}

      {currentContestant && !currentContestant.error && !isLoading && (
        <div className={styles['preview-section'] ?? ''}>
          <h3>Preview</h3>

          <div className={styles['form-group'] ?? ''}>
            <label htmlFor="contestant-name-input">
              Contestant Name{' '}
              <span style={{ color: 'var(--text-secondary)', fontWeight: 'normal' }}>
                (optional)
              </span>
              :
            </label>
            <input
              id="contestant-name-input"
              type="text"
              value={currentContestant.contestantName}
              onChange={(e) => {
                updateCurrentContestantName(e.target.value);
              }}
              placeholder="Leave empty to import category only"
            />
            <p
              style={{
                fontSize: '0.85rem',
                color: 'var(--text-secondary)',
                margin: '0.25rem 0 0 0',
              }}
            >
              If provided, a contestant will be created with this category. Otherwise, only the
              category will be imported.
            </p>
          </div>

          <div className={styles['form-group'] ?? ''}>
            <label htmlFor="category-name-input">Category Name:</label>
            <input
              id="category-name-input"
              type="text"
              value={currentContestant.categoryName}
              onChange={(e) => {
                updateCurrentCategoryName(e.target.value);
              }}
              placeholder="Enter category name"
              required
            />
          </div>

          <div className={styles['slides-summary'] ?? ''}>
            <h4>Slides: {currentContestant.category.slides.length}</h4>
            <p style={{ fontSize: '0.9rem', color: 'var(--text-secondary)', marginBottom: '1rem' }}>
              Click on any slide to expand and edit its answer. Answers are censored by default to
              prevent spoilers.
            </p>
            <div className={styles['slides-list'] ?? ''}>
              {currentContestant.category.slides.map((slide, index) => (
                <SlidePreview
                  key={index}
                  slide={slide}
                  slideNumber={index + 1}
                  mode="edit"
                  isExpanded={expandedSlideIndex === index}
                  onToggleExpand={() => {
                    toggleSlideExpanded(index);
                  }}
                  onAnswerChange={(newAnswer) => {
                    handleSlideAnswerChange(index, newAnswer);
                  }}
                />
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
